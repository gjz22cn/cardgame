<?xml version="1.0" encoding="UTF-8"?>
<project name="GameCard" default="release-package">
    
    <property environment="env" />

	<!-- 引入配置文件 -->
    <property file="package/project.properties" />
    <property file="package/channels-one.properties" />
    
    <!-- 定义版本参数 -->
   	<property name="version.code" value="${app.version.code}" />
    <property name="version.name" value="${app.version}" />
   
    <property name="verbose" value="false" />
    
    <!-- 定义临时目录及相关文件 -->
    <property name="bak.dir" value="${basedir}/package/bak/"/>
	<property name="bak.manifest" value="${basedir}/package/bak/AndroidManifest.xml"/>
	<property name="manifest.dir" value="${basedir}"/>
	<property name="manifest" value="${manifest.dir}/AndroidManifest.xml"/>
	<property name="out.final.dir" value="${basedir}/package/channel/"/>

    <property name="adb.device.arg" value="" />
    <property name="android.package.excludes" value="" />
    <property name="aapt.resource.filter" value="" />
    <property name="aapt.ignore.assets" value="" />
    <property name="dex.force.jumbo" value="false" />
    <property name="dex.disable.merger" value="false" />

    <!-- java 编译参数 -->
    <property name="java.encoding" value="UTF-8" />
    <property name="java.target" value="1.6" />
    <property name="java.source" value="1.6" />
    <property name="java.compilerargs" value="-encoding UTF-8" />
    <property name="java.compiler.classpath" value="" />

    <!-- Renderscript options -->
    <property name="renderscript.debug.opt.level" value="O0" />
    <property name="renderscript.release.opt.level" value="O3" />
    <property name="renderscript.support.mode" value="false" />
    <property name="manifestmerger.enabled" value="false" />

    <!-- instrumentation options -->
    <property name="emma.filter" value="" />
    <property name="lint.out.html" value="bin/lint-results.html" />
    <property name="lint.out.xml" value="bin/lint-results.xml" />

    <!-- 循环支持 -->
    <path id="android.antlibs">
        <pathelement path="${sdk.dir}/tools/lib/ant-tasks.jar" />
    </path>
    <taskdef resource="anttasks.properties" classpathref="android.antlibs" />
	<taskdef name="foreach" classname="net.sf.antcontrib.logic.ForEach">
        <classpath> 
			<pathelement location="${basedir}/package/ant-contrib-1.0b3.jar"/>
        </classpath>
    </taskdef>
    
    <taskdef name="propertyregex" classname="net.sf.antcontrib.property.RegexTask" >
        <classpath> 
			<pathelement location="${basedir}/package/ant-contrib-1.0b3.jar"/>
        </classpath>
    </taskdef>
	
    <!-- Emma 配置 -->
    <property name="emma.dir" value="${sdk.dir}/tools/lib" />
    <path id="emma.lib">
        <pathelement location="${emma.dir}/emma.jar" />
        <pathelement location="${emma.dir}/emma_ant.jar" />
    </path>
    <taskdef resource="emma_ant.properties" classpathref="emma.lib" />


    <!-- 初始文件和目录参数 -->
    <property name="source.dir" value="src" />
    <property name="source.absolute.dir" location="${source.dir}" />
    <property name="gen.absolute.dir" location="gen" />
    <property name="resource.absolute.dir" location="res" />
    <property name="asset.dir" value="assets" />
    <property name="asset.absolute.dir" location="${asset.dir}" />
    <property name="jar.libs.dir" value="libs" />
    <property name="jar.libs.absolute.dir" location="${jar.libs.dir}" />
    <property name="native.libs.absolute.dir" location="libs" />

    <property name="manifest.file" value="AndroidManifest.xml" />
    <property name="manifest.abs.file" location="${manifest.file}" />

    <!-- 输出的文件和目录参数 -->
    <property name="out.dir" value="bin" />
    <property name="out.absolute.dir" location="${out.dir}" />
    <property name="out.classes.absolute.dir" location="${out.dir}/classes" />
    <property name="out.res.absolute.dir" location="${out.dir}/res" />
    <property name="out.rs.obj.absolute.dir" location="${out.dir}/rsObj" />
    <property name="out.rs.libs.absolute.dir" location="${out.dir}/rsLibs" />
    <property name="out.aidl.absolute.dir" location="${out.dir}/aidl" />
    <property name="out.dexed.absolute.dir" location="${out.dir}/dexedLibs" />
    <property name="out.manifest.abs.file" location="${out.dir}/AndroidManifest.xml" />

    <!-- tools location -->
    <property name="android.tools.dir" location="${sdk.dir}/tools" />
    <property name="android.platform.tools.dir" location="${sdk.dir}/platform-tools" />
    <condition property="exe" value=".exe" else=""><os family="windows" /></condition>
    <condition property="bat" value=".bat" else=""><os family="windows" /></condition>
    <property name="adb" location="${android.platform.tools.dir}/adb${exe}" />
    <property name="zipalign" location="${android.tools.dir}/zipalign${exe}" />
    <property name="lint" location="${android.tools.dir}/lint${bat}" />

    <!-- Intermediate files -->
    <property name="dex.file.name" value="classes.dex" />
    <property name="intermediate.dex.file" location="${out.absolute.dir}/${dex.file.name}" />
    <property name="resource.package.file.name" value="${ant.project.name}.ap_" />

    <!-- Build property file -->
    <property name="out.build.prop.file" location="${out.absolute.dir}/build.prop" />


    <!-- This is needed by emma as it uses multilevel verbosity instead of simple 'true' or 'false'
         The property 'verbosity' is not user configurable and depends exclusively on 'verbose'
         value.-->
    <condition property="verbosity" value="verbose" else="quiet">
        <istrue value="${verbose}" />
    </condition>

    <!-- properties for signing in release mode -->
    <condition property="has.keystore">
        <and>
            <isset property="key.store" />
            <length string="${key.store}" when="greater" length="0" />
            <isset property="key.alias" />
        </and>
    </condition>
    <condition property="has.password">
        <and>
            <isset property="has.keystore" />
            <isset property="key.store.password" />
            <isset property="key.alias.password" />
        </and>
    </condition>

    <!-- properties for packaging -->
    <property name="build.packaging.nocrunch" value="true" />

    <!-- whether we need to fork javac.
         This is only needed on Windows when running Java < 7 -->
    <condition else="false" property="need.javac.fork">
        <and>
            <matches pattern="1\.[56]" string="${java.specification.version}"/>
            <not>
                <os family="unix"/>
            </not>
        </and>
    </condition>

    <!-- ******************************************************* -->
    <!-- ************************ Macros *********************** -->
    <!-- ******************************************************* -->

    <!-- macro to do a task on if project.is.library is false.
         elseText attribute is displayed otherwise -->
    <macrodef name="do-only-if-not-library">
        <attribute name="elseText" />
        <element name="task-to-do" implicit="yes" />
        <sequential>
        <if condition="${project.is.library}">
            <else>
                <task-to-do />
            </else>
            <then>
                <echo level="info">@{elseText}</echo>
            </then>
        </if>
        </sequential>
    </macrodef>

    <!-- macro to do a task on if manifest.hasCode is true.
         elseText attribute is displayed otherwise -->
    <macrodef name="do-only-if-manifest-hasCode">
        <attribute name="elseText" default=""/>
        <element name="task-to-do" implicit="yes" />
        <sequential>
        <if condition="${manifest.hasCode}">
            <then>
                <task-to-do />
            </then>
            <else>
                <if>
                    <condition>
                        <length string="@{elseText}" trim="true" when="greater" length="0" />
                    </condition>
                    <then>
                        <echo level="info">@{elseText}</echo>
                    </then>
                </if>
            </else>
        </if>
        </sequential>
    </macrodef>


    <!-- Configurable macro, which allows to pass as parameters output directory,
         output dex filename and external libraries to dex (optional) -->
    <macrodef name="dex-helper">
        <element name="external-libs" optional="yes" />
        <attribute name="nolocals" default="false" />
        <sequential>
            <!-- sets the primary input for dex. If a pre-dex task sets it to
                 something else this has no effect -->
            <property name="out.dex.input.absolute.dir" value="${out.classes.absolute.dir}" />

            <!-- set the secondary dx input: the project (and library) jar files
                 If a pre-dex task sets it to something else this has no effect -->
            <if>
                <condition>
                    <isreference refid="out.dex.jar.input.ref" />
                </condition>
                <else>
                    <path id="out.dex.jar.input.ref">
                        <path refid="project.all.jars.path" />
                    </path>
                </else>
            </if>

            <dex executable="${dx}"
                    output="${intermediate.dex.file}"
                    dexedlibs="${out.dexed.absolute.dir}"
                    nolocals="@{nolocals}"
                    forceJumbo="${dex.force.jumbo}"
                    disableDexMerger="${dex.disable.merger}"
                    verbose="${verbose}">
                <path path="${out.dex.input.absolute.dir}"/>
                <path refid="out.dex.jar.input.ref" />
                <external-libs />
            </dex>
        </sequential>
    </macrodef>

    <!-- This is macro that enable passing variable list of external jar files to ApkBuilder
         Example of use:
         <package-helper>
             <extra-jars>
                <jarfolder path="my_jars" />
                <jarfile path="foo/bar.jar" />
                <jarfolder path="your_jars" />
             </extra-jars>
         </package-helper> -->
    <macrodef name="package-helper">
        <element name="extra-jars" optional="yes" />
        <sequential>
            <apkbuilder
                    outfolder="${out.absolute.dir}"
                    resourcefile="${resource.package.file.name}"
                    apkfilepath="${out.packaged.file}"
                    debugpackaging="${build.is.packaging.debug}"
                    debugsigning="${build.is.signing.debug}"
                    verbose="${verbose}"
                    hascode="${manifest.hasCode}"
                    previousBuildType="${build.last.is.packaging.debug}/${build.last.is.signing.debug}"
                    buildType="${build.is.packaging.debug}/${build.is.signing.debug}">
                <dex path="${intermediate.dex.file}"/>
                <sourcefolder path="${source.absolute.dir}"/>
                <jarfile refid="project.all.jars.path" />
                <nativefolder path="${native.libs.absolute.dir}" />
                <nativefolder refid="project.library.native.folder.path" />
<!--                 <nativefolder refid="project.rs.support.libs.path" /> -->
                <nativefolder path="${out.rs.libs.absolute.dir}" />
                <extra-jars/>
            </apkbuilder>
        </sequential>
    </macrodef>

    <!-- This is macro which zipaligns in.package and outputs it to out.package. Used by targets
         debug, -debug-with-emma and release.-->
    <macrodef name="zipalign-helper">
        <attribute name="in.package" />
        <attribute name="out.package" />
        <sequential>
            <zipalign
                    executable="${zipalign}"
                    input="@{in.package}"
                    output="@{out.package}"
                    verbose="${verbose}" />
        </sequential>
    </macrodef>

    <macrodef name="run-tests-helper">
        <attribute name="emma.enabled" default="false" />
        <element name="extra-instrument-args" optional="yes" />
        <sequential>
            <echo level="info">Running tests ...</echo>
            <exec executable="${adb}" failonerror="true">
                <arg line="${adb.device.arg}" />
                <arg value="shell" />
                <arg value="am" />
                <arg value="instrument" />
                <arg value="-w" />
                <arg value="-e" />
                <arg value="coverage" />
                <arg value="@{emma.enabled}" />
                <extra-instrument-args />
                <arg value="${project.app.package}/${test.runner}" />
            </exec>
        </sequential>
    </macrodef>

    <macrodef name="record-build-key">
        <attribute name="key" default="false" />
        <attribute name="value" default="false" />
        <sequential>
            <propertyfile file="${out.build.prop.file}" comment="Last build type">
                <entry key="@{key}" value="@{value}"/>
            </propertyfile>
        </sequential>
    </macrodef>

    <macrodef name="record-build-info">
        <sequential>
            <record-build-key key="build.last.target" value="${build.target}" />
            <record-build-key key="build.last.is.instrumented" value="${build.is.instrumented}" />
            <record-build-key key="build.last.is.packaging.debug" value="${build.is.packaging.debug}" />
            <record-build-key key="build.last.is.signing.debug" value="${build.is.signing.debug}" />
        </sequential>
    </macrodef>


    <!-- ******************************************************* -->
    <!-- ******************** Build Targets ******************** -->
    <!-- ******************************************************* -->

    <!-- Basic Ant + SDK check -->
    <target name="-check-env">
        <checkenv />
    </target>

    <!-- target to disable building dependencies -->
    <target name="nodeps">
        <property name="dont.do.deps" value="true" />
    </target>

    <!-- generic setup -->
    <target name="-setup" depends="-check-env">
        <echo level="info">Project Name: ${ant.project.name}</echo>
        <gettype projectTypeOut="project.type" />

        <!-- sets a few boolean based on project.type
             to make the if task easier -->
        <condition property="project.is.library" value="true" else="false">
            <equals arg1="${project.type}" arg2="library" />
        </condition>
        <condition property="project.is.test" value="true" else="false">
            <equals arg1="${project.type}" arg2="test" />
        </condition>
        <condition property="project.is.testapp" value="true" else="false">
            <equals arg1="${project.type}" arg2="test-app" />
        </condition>

        <!-- If a test project, resolve absolute path to tested project. -->
        <if condition="${project.is.test}">
            <then>
                <property name="tested.project.absolute.dir" location="${tested.project.dir}" />
            </then>
        </if>

        <!-- get the project manifest package -->
        <xpath input="${manifest.abs.file}"
                expression="/manifest/@package" output="project.app.package" />

    </target>

    <!-- empty default pre-clean target. Create a similar target in
         your build.xml and it'll be called instead of this one. -->
    <target name="-pre-clean"/>

    <!-- clean target -->
    <target name="clean" depends="-setup, -pre-clean"
            description="Removes output files created by other targets.">
        <delete dir="${out.absolute.dir}" verbose="${verbose}" />
        <delete dir="${gen.absolute.dir}" verbose="${verbose}" />

        <!-- if we know about a tested project or libraries, we clean them too. -->
        <if condition="${project.is.test}">
            <then>
                <property name="tested.project.absolute.dir" location="${tested.project.dir}" />
                <subant failonerror="true">
                    <fileset dir="${tested.project.absolute.dir}" includes="build.xml" />
                    <target name="clean" />
                </subant>
            </then>
        </if>

        <!-- get all the libraries -->
        <if>
            <condition><not><isset property="dont.do.deps" /></not></condition>
            <then>
                <getlibpath libraryFolderPathOut="project.library.folder.path" />
                <if>
                    <condition>
                        <isreference refid="project.library.folder.path" />
                    </condition>
                    <then>
                        <!-- clean the libraries with nodeps since we already
                             know about all the libraries even the indirect one -->
                        <subant
                                buildpathref="project.library.folder.path"
                                antfile="build.xml"
                                failonerror="true">
                            <target name="nodeps" />
                            <target name="clean" />
                        </subant>
                    </then>
                </if>
            </then>
        </if>
    </target>

    <!-- Pre build setup -->
    <target name="-build-setup" depends="-setup">
        <getbuildtools name="android.build.tools.dir" />
        <property name="aidl" location="${android.build.tools.dir}/aidl${exe}" />
        <property name="aapt" location="${android.build.tools.dir}/aapt${exe}" />
        <property name="dx" location="${android.build.tools.dir}/dx${bat}" />

        <!-- read the previous build mode -->
        <property file="${out.build.prop.file}" />
        <!-- if empty the props won't be set, meaning it's a new build.
             To force a build, set the prop to empty values. -->
        <property name="build.last.target" value="" />
        <property name="build.last.is.instrumented" value="" />
        <property name="build.last.is.packaging.debug" value="" />
        <property name="build.last.is.signing.debug" value="" />

        <!-- If the "debug" build type changed, clear out the compiled code.
             This is to make sure the new BuildConfig.DEBUG value is picked up
             as javac can't deal with this type of change in its dependency computation. -->
        <if>
            <condition>
                <and>
                    <length string="${build.last.is.packaging.debug}" trim="true" when="greater" length="0" />
                    <not><equals arg1="${build.is.packaging.debug}" arg2="${build.last.is.packaging.debug}" /></not>
                </and>
            </condition>
            <then>
                <echo level="info">Switching between debug and non debug build: Deleting previous compilation output...</echo>
                <delete dir="${out.classes.absolute.dir}" verbose="${verbose}" />
            </then>
            <else>
                <!-- Else, we may still need to clean the code, for another reason.
                     special case for instrumented: if the previous build was
                     instrumented but not this one, clear out the compiled code -->
                <if>
                    <condition>
                        <and>
                            <istrue value="${build.last.is.instrumented}" />
                            <isfalse value="${build.is.instrumented}" />
                        </and>
                    </condition>
                    <then>
                        <echo level="info">Switching from instrumented to non-instrumented build: Deleting previous compilation output...</echo>
                        <delete dir="${out.classes.absolute.dir}" verbose="${verbose}" />
                    </then>
                </if>
            </else>
        </if>

        <echo level="info">Resolving Build Target for ${ant.project.name}...</echo>
        <gettarget
                androidJarFileOut="project.target.android.jar"
                androidAidlFileOut="project.target.framework.aidl"
                bootClassPathOut="project.target.class.path"
                targetApiOut="project.target.apilevel"
                minSdkVersionOut="project.minSdkVersion" />

        <!-- Value of the hasCode attribute (Application node) extracted from manifest file -->
        <xpath input="${manifest.abs.file}" expression="/manifest/application/@android:hasCode"
                    output="manifest.hasCode" default="true"/>

        <echo level="info">----------</echo>
        <echo level="info">Creating output directories if needed...</echo>
        <mkdir dir="${resource.absolute.dir}" />
        <mkdir dir="${jar.libs.absolute.dir}" />
        <mkdir dir="${out.absolute.dir}" />
        <mkdir dir="${out.res.absolute.dir}" />
        <mkdir dir="${out.rs.obj.absolute.dir}" />
        <mkdir dir="${out.rs.libs.absolute.dir}" />
        <do-only-if-manifest-hasCode>
            <mkdir dir="${gen.absolute.dir}" />
            <mkdir dir="${out.classes.absolute.dir}" />
            <mkdir dir="${out.dexed.absolute.dir}" />
        </do-only-if-manifest-hasCode>

        <echo level="info">----------</echo>
        <echo level="info">Resolving Dependencies for ${ant.project.name}...</echo>
        <dependency
                libraryFolderPathOut="project.library.folder.path"
                libraryPackagesOut="project.library.packages"
                libraryManifestFilePathOut="project.library.manifest.file.path"
                libraryResFolderPathOut="project.library.res.folder.path"
                libraryBinAidlFolderPathOut="project.library.bin.aidl.folder.path"
                libraryRFilePathOut="project.library.bin.r.file.path"
                libraryNativeFolderPathOut="project.library.native.folder.path"
                jarLibraryPathOut="project.all.jars.path"
                targetApi="${project.target.apilevel}"
                verbose="${verbose}" />
<!--  renderscriptSupportMode="${renderscript.support.mode}"
buildToolsFolder="${android.build.tools.dir}"
renderscriptSupportLibsOut="project.rs.support.libs.path"
 -->
        <!-- compile the libraries if any -->
        <if>
            <condition>
                <and>
                    <isreference refid="project.library.folder.path" />
                    <not><isset property="dont.do.deps" /></not>
                </and>
            </condition>
            <then>
                <!-- figure out which target must be used to build the library projects.
                     If emma is enabled, then use 'instrument' otherwise, use 'debug' -->
                <condition property="project.libraries.target" value="instrument" else="${build.target}">
                    <istrue value="${build.is.instrumented}" />
                </condition>

                <echo level="info">----------</echo>
                <echo level="info">Building Libraries with '${project.libraries.target}'...</echo>

                <!-- no need to build the deps as we have already
                     the full list of libraries -->
                <subant failonerror="true"
                        buildpathref="project.library.folder.path"
                        antfile="build.xml">
                    <target name="nodeps" />
                    <target name="${project.libraries.target}" />
                    <property name="emma.coverage.absolute.file" location="${out.absolute.dir}/coverage.em" />
                </subant>
            </then>
        </if>

        <!-- compile the main project if this is a test project -->
        <if condition="${project.is.test}">
            <then>
                <!-- figure out which target must be used to build the tested project.
                     If emma is enabled, then use 'instrument' otherwise, use 'debug' -->
                <condition property="tested.project.target" value="instrument" else="debug">
                    <isset property="emma.enabled" />
                </condition>

                <echo level="info">----------</echo>
                <echo level="info">Building tested project at ${tested.project.absolute.dir} with '${tested.project.target}'...</echo>
                <subant target="${tested.project.target}" failonerror="true">
                    <fileset dir="${tested.project.absolute.dir}" includes="build.xml" />
                </subant>

                <!-- get the tested project full classpath to be able to build
                     the test project -->
                <testedprojectclasspath
                        projectLocation="${tested.project.absolute.dir}"
                        projectClassPathOut="tested.project.classpath"/>
            </then>
            <else>
                <!-- no tested project, make an empty Path object so that javac doesn't
                     complain -->
                <path id="tested.project.classpath" />
            </else>
        </if>
    </target>

    <!-- Code Generation: compile resources (aapt -> R.java), aidl, renderscript -->
    <target name="-code-gen">
        <mergemanifest
                appManifest="${manifest.abs.file}"
                outManifest="${out.manifest.abs.file}"
                enabled="${manifestmerger.enabled}">
            <library refid="project.library.manifest.file.path" />
        </mergemanifest>

        <do-only-if-manifest-hasCode
                elseText="hasCode = false. Skipping aidl/renderscript/R.java">
            <echo level="info">Handling aidl files...</echo>
            <aidl executable="${aidl}"
                    framework="${project.target.framework.aidl}"
                    libraryBinAidlFolderPathRefid="project.library.bin.aidl.folder.path"
                    genFolder="${gen.absolute.dir}"
                    aidlOutFolder="${out.aidl.absolute.dir}">
                <source path="${source.absolute.dir}"/>
            </aidl>

            <!-- renderscript generates resources so it must be called before aapt -->
            <echo level="info">----------</echo>
            <echo level="info">Handling RenderScript files...</echo>
            <property name="renderscript.target" value="${project.minSdkVersion}" />
            <echo level="info">----------</echo>
            <echo level="info">Handling Resources...</echo>
            <aapt executable="${aapt}"
                    command="package"
                    verbose="${verbose}"
                    manifest="${out.manifest.abs.file}"
                    originalManifestPackage="${project.app.package}"
                    androidjar="${project.target.android.jar}"
                    rfolder="${gen.absolute.dir}"
                    nonConstantId="${android.library}"
                    libraryResFolderPathRefid="project.library.res.folder.path"
                    libraryPackagesRefid="project.library.packages"
                    libraryRFileRefid="project.library.bin.r.file.path"
                    ignoreAssets="${aapt.ignore.assets}"
                    binFolder="${out.absolute.dir}"
                    proguardFile="${out.absolute.dir}/proguard.txt">
                <res path="${out.res.absolute.dir}" />
                <res path="${resource.absolute.dir}" />
            </aapt>

            <echo level="info">----------</echo>
            <echo level="info">Handling BuildConfig class...</echo>
            <buildconfig
                    genFolder="${gen.absolute.dir}"
                    package="${project.app.package}"
                    buildType="${build.is.packaging.debug}"
                    previousBuildType="${build.last.is.packaging.debug}"/>

        </do-only-if-manifest-hasCode>
    </target>

    <target name="-compile" depends="-build-setup, -code-gen">
        <do-only-if-manifest-hasCode elseText="hasCode = false. Skipping...">
            <path id="project.javac.classpath">
                <path refid="project.all.jars.path" />
                <path refid="tested.project.classpath" />
                <path path="${java.compiler.classpath}" />
            </path>
            <javac encoding="${java.encoding}"
                    source="${java.source}" target="${java.target}"
                    debug="true" extdirs="" includeantruntime="false"
                    destdir="${out.classes.absolute.dir}"
                    bootclasspathref="project.target.class.path"
                    verbose="${verbose}"
                    classpathref="project.javac.classpath">
                <src path="${source.absolute.dir}" />
                <src path="${gen.absolute.dir}" />
                <compilerarg line="${java.compilerargs}" />
            </javac>

            <if condition="${build.is.instrumented}">
                <then>
                    <echo level="info">Instrumenting classes from ${out.absolute.dir}/classes...</echo>
                    <getemmafilter
                            appPackage="${project.app.package}"
                            libraryPackagesRefId="project.library.packages"
                            filterOut="emma.default.filter"/>
                    <property name="emma.coverage.absolute.file" location="${out.absolute.dir}/coverage.em" />
                    <emma enabled="true">
                        <instr verbosity="${verbosity}"
                               mode="overwrite"
                               instrpath="${out.absolute.dir}/classes"
                               outdir="${out.absolute.dir}/classes"
                               metadatafile="${emma.coverage.absolute.file}">
                            <filter excludes="${emma.default.filter}" />
                            <filter value="${emma.filter}" />
                        </instr>
                    </emma>
                </then>
            </if>
            <if condition="${project.is.library}">
                <then>
                    <echo level="info">Creating library output jar file...</echo>
                    <property name="out.library.jar.file" location="${out.absolute.dir}/classes.jar" />
                    <if>
                        <condition>
                            <length string="${android.package.excludes}" trim="true" when="greater" length="0" />
                        </condition>
                        <then>
                            <echo level="info">Custom jar packaging exclusion: ${android.package.excludes}</echo>
                        </then>
                    </if>

                    <propertybyreplace name="project.app.package.path" input="${project.app.package}" replace="." with="/" />

                    <jar destfile="${out.library.jar.file}">
                        <fileset dir="${out.classes.absolute.dir}"
                                includes="**/*.class"
                                excludes="${project.app.package.path}/R.class ${project.app.package.path}/R$*.class ${project.app.package.path}/BuildConfig.class"/>
                        <fileset dir="${source.absolute.dir}" excludes="**/*.java ${android.package.excludes}" />
                    </jar>
                </then>
            </if>

        </do-only-if-manifest-hasCode>
    </target>
    
    <target name="-obfuscate">
        <if condition="${proguard.enabled}">
            <then>
                <property name="obfuscate.absolute.dir" location="${out.absolute.dir}/proguard" />
                <property name="preobfuscate.jar.file" value="${obfuscate.absolute.dir}/original.jar" />
                <property name="obfuscated.jar.file" value="${obfuscate.absolute.dir}/obfuscated.jar" />
                <!-- input for dex will be proguard's output -->
                <property name="out.dex.input.absolute.dir" value="${obfuscated.jar.file}" />

                <!-- Add Proguard Tasks -->
                <property name="proguard.jar" location="${android.tools.dir}/proguard/lib/proguard.jar" />
                <taskdef name="proguard" classname="proguard.ant.ProGuardTask" classpath="${proguard.jar}" />

                <pathconvert property="project.target.classpath.value" refid="project.target.class.path">
                    <firstmatchmapper>
                        <regexpmapper from='^([^ ]*)( .*)$$' to='"\1\2"'/>
                        <identitymapper/>
                    </firstmatchmapper>
                </pathconvert>

                <path id="project.all.classes.path">
                    <pathelement location="${preobfuscate.jar.file}" />
                    <path refid="project.all.jars.path" />
                </path>
                <pathconvert property="project.all.classes.value" refid="project.all.classes.path">
                    <firstmatchmapper>
                        <regexpmapper from='^([^ ]*)( .*)$$' to='"\1\2"'/>
                        <identitymapper/>
                    </firstmatchmapper>
                </pathconvert>

                <path id="proguard.configpath">
                    <pathelement path="${proguard.config}"/>
                </path>
                <pathconvert pathsep='" -include "' property="proguard.configcmd" refid="proguard.configpath"/>

                <mkdir   dir="${obfuscate.absolute.dir}" />
                <delete file="${preobfuscate.jar.file}"/>
                <delete file="${obfuscated.jar.file}"/>
                <jar basedir="${out.classes.absolute.dir}"
                    destfile="${preobfuscate.jar.file}" />
                <proguard>
                    -include      "${proguard.configcmd}"
                    -include      "${out.absolute.dir}/proguard.txt"
                    -injars       ${project.all.classes.value}
                    -outjars      "${obfuscated.jar.file}"
                    -libraryjars  ${project.target.classpath.value}
                    -dump         "${obfuscate.absolute.dir}/dump.txt"
                    -printseeds   "${obfuscate.absolute.dir}/seeds.txt"
                    -printusage   "${obfuscate.absolute.dir}/usage.txt"
                    -printmapping "${obfuscate.absolute.dir}/mapping.txt"
                </proguard>
            </then>
        </if>
    </target>

    <target name="-dex" depends="-compile,-obfuscate">
        <do-only-if-manifest-hasCode elseText="hasCode = false. Skipping...">
            <!-- only convert to dalvik bytecode is *not* a library -->
            <do-only-if-not-library elseText="Library project: do not convert bytecode..." >
                <!-- special case for instrumented builds: need to use no-locals and need
                     to pass in the emma jar. -->
                <if condition="${build.is.instrumented}">
                    <then>
                        <dex-helper nolocals="true">
                            <external-libs>
                                <fileset file="${emma.dir}/emma_device.jar" />
                            </external-libs>
                        </dex-helper>
                    </then>
                    <else>
                        <dex-helper />
                    </else>
                </if>
            </do-only-if-not-library>
        </do-only-if-manifest-hasCode>
    </target>

    <target name="-crunch">
        <exec executable="${aapt}" taskName="crunch">
            <arg value="crunch" />
            <arg value="-v" />
            <arg value="-S" />
            <arg path="${resource.absolute.dir}" />
            <arg value="-C" />
            <arg path="${out.res.absolute.dir}" />
        </exec>
    </target>

    <target name="-package-resources" depends="-crunch">
        <do-only-if-not-library elseText="Library project: do not package resources..." >
           <aapt executable="${aapt}"
                   command="package"
                   versioncode="${version.code}"
                   versionname="${version.name}"
                   debug="${build.is.packaging.debug}"
                   manifest="${out.manifest.abs.file}"
                   assets="${asset.absolute.dir}"
                   androidjar="${project.target.android.jar}"
                   apkfolder="${out.absolute.dir}"
                   nocrunch="${build.packaging.nocrunch}"
                   resourcefilename="${resource.package.file.name}"
                   resourcefilter="${aapt.resource.filter}"
                   libraryResFolderPathRefid="project.library.res.folder.path"
                   libraryPackagesRefid="project.library.packages"
                   libraryRFileRefid="project.library.bin.r.file.path"
                   previousBuildType="${build.last.target}"
                   buildType="${build.target}"
                   ignoreAssets="${aapt.ignore.assets}">
               <res path="${out.res.absolute.dir}" />
               <res path="${resource.absolute.dir}" />
               <!-- <nocompress /> forces no compression on any files in assets or res/raw -->
               <!-- <nocompress extension="xml" /> forces no compression on specific file extensions in assets and res/raw -->
           </aapt>
        </do-only-if-not-library>
    </target>

    <!-- Packages the application. -->
    <target name="-package" depends="-package-resources">
        <!-- only package apk if *not* a library project -->
        <do-only-if-not-library elseText="Library project: do not package apk..." >
            <if condition="${build.is.instrumented}">
                <then>
                    <package-helper>
                        <extra-jars>
                            <!-- Injected from external file -->
                            <jarfile path="${emma.dir}/emma_device.jar" />
                        </extra-jars>
                    </package-helper>
                </then>
                <else>
                    <package-helper />
                </else>
            </if>
        </do-only-if-not-library>
    </target>

    <target name="-set-mode-check">
        <fail if="build.is.mode.set"
                message="Cannot run two different modes at the same time. If you are running more than one debug/release/instrument type targets, call them from different Ant calls." />
    </target>

    <!-- ******************************************************* -->
    <!-- **************** Debug specific targets *************** -->
    <!-- ******************************************************* -->

    <target name="-set-debug-files" depends="-set-mode-check">

        <property name="out.packaged.file" location="${out.absolute.dir}/${ant.project.name}-debug-unaligned.apk" />
        <property name="out.final.file" location="${out.absolute.dir}/${ant.project.name}-debug.apk" />
        <property name="build.is.mode.set" value="true" />
    </target>


    <target name="-set-debug-mode" depends="-setup">
        <!-- record the current build target -->
        <property name="build.target" value="debug" />

        <if>
            <condition>
                <and>
                    <istrue value="${project.is.testapp}" />
                    <istrue value="${emma.enabled}" />
                </and>
            </condition>
            <then>
                <property name="build.is.instrumented" value="true" />
            </then>
            <else>
                <property name="build.is.instrumented" value="false" />
            </else>
        </if>

        <!-- whether the build is a debug build. always set. -->
        <property name="build.is.packaging.debug" value="true" />

        <!-- signing mode: debug -->
        <property name="build.is.signing.debug" value="true" />

        <!-- Renderscript optimization level: none -->
        <property name="renderscript.opt.level" value="${renderscript.debug.opt.level}" />

    </target>

    <target name="-debug-obfuscation-check">
        <!-- proguard is never enabled in debug mode -->
        <property name="proguard.enabled" value="false"/>
    </target>

    <!-- Builds debug output package -->
    <target name="-do-debug" depends="-set-debug-mode, -debug-obfuscation-check, -package">
        <!-- only create apk if *not* a library project -->
        <do-only-if-not-library elseText="Library project: do not create apk..." >
            <sequential>
                <zipalign-helper in.package="${out.packaged.file}" out.package="${out.final.file}" />
                <echo level="info">Debug Package: ${out.final.file}</echo>
            </sequential>
        </do-only-if-not-library>
        <record-build-info />
    </target>

    <!-- Builds debug output package -->
    <target name="debug" depends="-set-debug-files, -do-debug"
                description="Builds the application and signs it with a debug key.">
    </target>


    <!-- ******************************************************* -->
    <!-- *************** Release specific targets ************** -->
    <!-- ******************************************************* -->

    <!-- called through target 'release'. Only executed if the keystore and
         key alias are known but not their password. -->
    <target name="-release-prompt-for-password" if="has.keystore" unless="has.password">
        <!-- Gets passwords -->
        <input
                message="Please enter keystore password (store:${key.store}):"
                addproperty="key.store.password" />
        <input
                message="Please enter password for alias '${key.alias}':"
                addproperty="key.alias.password" />
    </target>


    <target name="-release-obfuscation-check">
        <echo level="info">混淆配置文件　 :  ${proguard.config}</echo>
        <condition property="proguard.enabled" value="true" else="false">
            <and>
                <isset property="build.is.mode.release" />
                <isset property="proguard.config" />
            </and>
        </condition>
        <if condition="${proguard.enabled}">
            <then>
                <echo level="info">Proguard.config is enabled</echo>
                <path id="out.dex.jar.input.ref" />
            </then>
        </if>
    </target>

    <target name="-set-release-mode">
        <property name="out.packaged.file" location="${out.absolute.dir}/${ant.project.name}-release-unsigned.apk" />
        <property name="out.final.file" location="${out.absolute.dir}/${ant.project.name}_${version.name}_${cl_upd}.apk" />
		<property name="build.is.mode.set" value="true" />

        <property name="build.target" value="release" />
        <property name="build.is.instrumented" value="false" />

        <xpath input="${manifest.abs.file}" expression="/manifest/application/@android:debuggable"
                output="build.is.packaging.debug" default="false"/>

        <property name="build.is.signing.debug" value="false" />

        <!-- Renderscript optimization level: aggressive -->
        <property name="renderscript.opt.level" value="${renderscript.release.opt.level}" />

        <if condition="${build.is.packaging.debug}">
            <then>
                <echo>*************************************************</echo>
                <echo>****  Android Manifest has debuggable=true   ****</echo>
                <echo>**** Doing DEBUG packaging with RELEASE keys ****</echo>
                <echo>*************************************************</echo>
            </then>
            <else>
                <!-- property only set in release mode.
                     Useful for if/unless attributes in target node
                     when using Ant before 1.8 -->
                <property name="build.is.mode.release" value="true"/>
            </else>
        </if>
    </target>

    <target name="-release-sign" if="has.keystore" >
        <do-only-if-not-library elseText="Library project: do not create apk..." >
            <sequential>
                <property name="out.unaligned.file" location="${out.absolute.dir}/${ant.project.name}-release-unaligned.apk" />

                <!-- Signs the APK -->
                <echo level="info">APK签名中 ...</echo>
                <signapk
                        input="${out.packaged.file}"
                        output="${out.unaligned.file}"
                        keystore="${key.store}"
                        storepass="${key.store.password}"
                        alias="${key.alias}"
                        keypass="${key.alias.password}"/>

                <!-- Zip aligns the APK -->
                <zipalign-helper
                        in.package="${out.unaligned.file}"
                        out.package="${out.final.file}" />
                <echo level="info">Release Package: ${out.final.file}</echo>
            </sequential>
        </do-only-if-not-library>
        <record-build-info />
    </target>

    <target name="-release-nosign" unless="has.keystore">
        <do-only-if-not-library elseText="" >
            <sequential>
                <echo level="info">No key.store and key.alias properties found in build.properties.</echo>
                <echo level="info">Please sign ${out.packaged.file} manually</echo>
                <echo level="info">and run zipalign from the Android SDK tools.</echo>
            </sequential>
        </do-only-if-not-library>
        <record-build-info />
    </target>
    
    <!-- -release-nosign, -->
    <target name="release"
                depends="-set-release-mode,-build-setup,-package,-release-prompt-for-password,-release-sign,-bak-apk"
                description="Builds the application in release mode.">
    </target>
    
	<!--循环打包 -->
	<target name="release-package" depends="clean,-set-release-mode,-release-obfuscation-check,-dex">
	   <foreach target="modify_cfg" list="${package_channel_list}" param="channel" delimiter="," />
	   <!-- 还原文件官方文件 -->
	   <echo level="info">.....清除本次的打包动作......</echo>
	   <antcall target="clean"/>
    </target>
	
    <target name="modify_cfg">
<!--         <delete file="${bak.manifest}" /> -->
<!-- 	   	使用官方原配置文件 -->
<!-- 	   	<copy todir="${bak.dir}" file="${manifest}" encoding="utf-8" overwrite="true"/> -->
<!--         获取umeng的渠道配置 -->
		<propertyregex override="true" property="cl_umeng" input="${channel}" regexp="umeng_(.*)#conf_" select="\1" />
<!-- 		获取APK渠道名称 -->
		<propertyregex override="true" property="cl_conf" input="${channel}" regexp="#conf_(.*)#upd_" select="\1" />
<!-- 		　获取APK包更新目录 -->
		<propertyregex override="true" property="cl_upd" input="${channel}" regexp="#upd_(.*)#batch_" select="\1" />
<!-- 		　获取激活批次号 -->
		<propertyregex override="true" property="cl_batch" input="${channel}" regexp="#batch_(.*)" select="\1" />
		
        <echo>当前配置信息　：　${cl_umeng} - ${cl_conf} - ${cl_upd} - ${cl_batch}</echo>
       	
<!-- 	   	<replace encoding="utf-8" file ="${bak.manifest}" token="umeng_test" value="${cl_umeng}"/> -->
<!-- 	   	<replace encoding="utf-8" file ="${bak.manifest}" token="conf_test" value="${cl_conf}"/> -->
<!-- 	   	<replace encoding="utf-8" file ="${bak.manifest}" token="udp_test" value="${cl_upd}"/> -->
<!-- 	   	<replace encoding="utf-8" file ="${bak.manifest}" token="game:212389" value="game:${cl_batch}"/> -->
	   
	   <!-- 将替换后的manifest拷贝到bin目录下 -->
<!-- 	   <copy tofile="${out.manifest.abs.file}" file="${bak.manifest}" encoding="utf-8" overwrite="true"/> -->
	   <!-- 打包流程 -->
	   <antcall target="release"/>
    </target>
    
    <!-- 保存发布apk文件 -->
    <target name="-bak-apk" depends="release-mm-apk">
        <echo>...........破解mmsdk中...........</echo>
    </target>
<!--     <target name="-bak-apk"> -->
<!--         <echo>...........  保存发布apk文件...........</echo> -->
<!-- 	   <copy todir="${out.final.dir}" file="${out.final.file}"/> -->
<!--     </target> -->
    
    
    <!-- 再次打包需要用到的文件目录 -->
    <property name="crack.tool.dir" value="${basedir}/package/tools" />
    <property name="unsignapk" value="${bak.dir}/unsign.apk" />
    <property name="run-jar" value="${crack.tool.dir}/SignAPK.jar" />
    
    <!-- 破解ＭＭ支付后重新打包 -->
    <target name="release-mm-apk" depends="unzip-old-apk,unzip-re-package">
        <echo> ...........破解重新签名中 ...........</echo>
        <delete dir="${out.final.file}" />
		<java jar="${run-jar}" fork="true">  
		    <arg value="${unsignapk}" />
		    <arg value="${out.final.dir}/g.apk" />
        </java>  
        <!-- 打完包后按服务器上的目录存放 -->
        <mkdir dir="${out.final.dir}/${cl_upd}/dz"/>
        <copy todir="${out.final.dir}/${cl_upd}/dz" file="${crack.tool.dir}/v.json"/>
        <copy todir="${out.final.dir}/${cl_upd}/dz" file="${out.final.dir}/g.apk"/>
        <delete dir="${unsignapk}" />
        <delete dir="${bak.dir}/target" />
    </target>
    
    <property name="mmdir" value="${mm.conf.dir}" />
    <property name="mm-copy-right" value="CopyrightDeclaration.xml" />
    <property name="mmiap" value="mmiap.xml" />
    <property name="mmv" value="VERSION" />
    
    <target name="unzip-old-apk">
		<echo> ...........破解开始解压原包 ...........</echo>
		<delete dir="${bak.dir}/target" />
		<mkdir dir="${bak.dir}/target" />
		<unzip dest="${bak.dir}/target" src="${out.final.file}" />
		
		<!-- 替换MM支付的签名认证文件 -->
		<delete file="${bak.dir}/target/${mm-copy-right}" />
		<delete file="${bak.dir}/target/${mmiap}" />
		<copy todir="${bak.dir}/target" file="${crack.tool.dir}/${mmdir}/${mm-copy-right}" encoding="utf-8" overwrite="true"/>
		<copy todir="${bak.dir}/target" file="${crack.tool.dir}/${mmdir}/${mmiap}" encoding="utf-8" overwrite="true"/>
		<copy todir="${bak.dir}/target" file="${crack.tool.dir}/${mmdir}/${mmv}" encoding="utf-8" overwrite="true"/>
	</target>
	
    <!-- 将替换文件后的解压包重新打包成APK -->
    <target name="unzip-re-package">
		<echo>...........破解重新打包成未签证的apk....</echo>
		<exec executable="${aapt}" failonerror="true">
			<arg value="p" />
			<arg value="-f" />
			<arg value="-F" />
			<arg value="${unsignapk}" />
			<arg value="${bak.dir}/target" />
		</exec>
	</target>
    

</project>